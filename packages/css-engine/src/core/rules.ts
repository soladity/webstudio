import type { Style, StyleProperty, StyleValue } from "../schema";
import { toValue, type TransformValue } from "./to-value";
import { toProperty } from "./to-property";

type Declaration = {
  breakpoint: string;
  selector: string;
  property: StyleProperty;
  value: StyleValue;
};

type DeclarationKey = Omit<Declaration, "value">;

const getDeclarationKey = (declaraionKey: DeclarationKey) => {
  const { breakpoint, selector, property } = declaraionKey;
  return `${breakpoint}:${selector}:${property}`;
};

/**
 * Reusable style rule in any nesting rule
 *
 * @mixin name {
 *   \@media breakpoint {
 *     &selector {
 *       property: value
 *     }
 *   }
 * }
 */
export class MixinRule {
  // use map to avoid duplicated properties
  #declarations = new Map<string, Declaration>();
  #dirtyBreakpoints = new Set<string>();
  /*
   * check if breakpoint was updated
   */
  isDirtyBreakpoint(breakpoint: string) {
    return this.#dirtyBreakpoints.has(breakpoint);
  }
  /**
   * reset breakpoints invalidation
   */
  clearBreakpoints() {
    this.#dirtyBreakpoints.clear();
  }
  setDeclaration(declaration: Declaration) {
    this.#declarations.set(getDeclarationKey(declaration), declaration);
    this.#dirtyBreakpoints.add(declaration.breakpoint);
  }
  deleteDeclaration(declaration: DeclarationKey) {
    this.#declarations.delete(getDeclarationKey(declaration));
    this.#dirtyBreakpoints.add(declaration.breakpoint);
  }
  getDeclarations() {
    return this.#declarations.values();
  }
}

/**
 * Universal style rule with nested selectors and media queries support
 * Rules are generated by each media query
 * and heavily cached to avoid complex computation
 *
 * selector {
 *   \@media breakpoint {
 *     &selector {
 *       property: value
 *     }
 *   }
 * }
 */
export class NestingRule {
  #selector: string;
  #descendentSuffix: string;
  #mixinRules = new Map<string, MixinRule>();
  #mixins = new Set<string>();
  // use map to avoid duplicated properties
  #declarations = new Map<string, Declaration>();
  // cached generated rule by breakpoint
  #cache = new Map<
    string,
    { generated: string; indent: number; transformValue?: TransformValue }
  >();
  constructor(
    mixinRules: Map<string, MixinRule>,
    selector: string,
    descendentSuffix: string
  ) {
    this.#selector = selector;
    this.#descendentSuffix = descendentSuffix;
    this.#mixinRules = mixinRules;
  }
  getSelector() {
    return this.#selector;
  }
  setSelector(selector: string) {
    this.#selector = selector;
    this.#cache.clear();
  }
  getDescendentSuffix() {
    return this.#descendentSuffix;
  }
  addMixin(mixin: string) {
    this.#mixins.add(mixin);
    this.#cache.clear();
  }
  applyMixins(mixins: string[]) {
    this.#mixins = new Set(mixins);
    this.#cache.clear();
  }
  setDeclaration(declaration: Declaration) {
    this.#declarations.set(getDeclarationKey(declaration), declaration);
    this.#cache.delete(declaration.breakpoint);
  }
  deleteDeclaration(declaration: DeclarationKey) {
    this.#declarations.delete(getDeclarationKey(declaration));
    this.#cache.delete(declaration.breakpoint);
  }
  getDeclarations() {
    // apply mixins first and then merge added declarations
    const declarations = new Map<string, Declaration>();
    for (const mixin of this.#mixins) {
      const rule = this.#mixinRules.get(mixin);
      if (rule === undefined) {
        continue;
      }
      for (const declaration of rule.getDeclarations()) {
        declarations.set(getDeclarationKey(declaration), declaration);
      }
    }
    for (const declaration of this.#declarations.values()) {
      declarations.set(getDeclarationKey(declaration), declaration);
    }
    return declarations.values();
  }
  toString({
    breakpoint,
    indent = 0,
    transformValue,
  }: {
    breakpoint: string;
    indent?: number;
    transformValue?: TransformValue;
  }) {
    for (const mixin of this.#mixins) {
      const rule = this.#mixinRules.get(mixin);
      // invalidate cache when mixin is changed
      if (rule?.isDirtyBreakpoint(breakpoint)) {
        this.#cache.delete(breakpoint);
      }
    }

    const cached = this.#cache.get(breakpoint);
    // invalidate cache when indent and value transformer are changed
    if (
      cached &&
      cached.indent === indent &&
      cached.transformValue === transformValue
    ) {
      return cached.generated;
    }
    const spaces = " ".repeat(indent);
    const linesBySelector = new Map<string, string>();
    for (const declaration of this.getDeclarations()) {
      // generate declarations only for specified breakpoint
      if (declaration.breakpoint !== breakpoint) {
        continue;
      }
      const { selector: nestedSelector, property, value } = declaration;
      const selector = this.#selector + this.#descendentSuffix + nestedSelector;
      const lines = linesBySelector.get(selector) ?? "";
      const propertyString = toProperty(property);
      const valueString = toValue(value, transformValue);
      const line = `${spaces}  ${propertyString}: ${valueString}`;
      linesBySelector.set(selector, lines === "" ? line : `${lines};\n${line}`);
    }
    // sort by selector to put values without nested selector first
    const generated = Array.from(linesBySelector)
      .sort(([leftSelector], [rightSelector]) =>
        leftSelector.localeCompare(rightSelector)
      )
      .map(
        ([selector, lines]) => `${spaces}${selector} {\n${lines}\n${spaces}}\n`
      )
      .join("")
      .trimEnd();
    this.#cache.set(breakpoint, { generated, indent, transformValue });
    return generated;
  }
}

export class StylePropertyMap {
  #cached: undefined | string;
  #styleMap: Map<StyleProperty, StyleValue | undefined> = new Map();
  #indent = 0;
  #transformValue?: TransformValue;
  constructor(style: Style) {
    let property: StyleProperty;
    for (property in style) {
      this.#styleMap.set(property, style[property]);
    }
  }
  set(property: StyleProperty, value?: StyleValue) {
    this.#styleMap.set(property, value);
    this.#cached = undefined;
  }
  get(property: StyleProperty) {
    return this.#styleMap.get(property);
  }
  has(property: StyleProperty) {
    return this.#styleMap.has(property);
  }
  get size() {
    return this.#styleMap.size;
  }
  keys() {
    return this.#styleMap.keys();
  }
  delete(property: StyleProperty) {
    this.#styleMap.delete(property);
    this.#cached = undefined;
  }
  clear() {
    this.#styleMap.clear();
    this.#cached = undefined;
  }
  toString({
    indent = 0,
    transformValue,
  }: { indent?: number; transformValue?: TransformValue } = {}) {
    // invalidate cache when indent is changed
    if (
      this.#cached &&
      indent === this.#indent &&
      transformValue === this.#transformValue
    ) {
      return this.#cached;
    }
    const block: Array<string> = [];
    const spaces = " ".repeat(indent);
    for (const [property, value] of this.#styleMap) {
      if (value === undefined) {
        continue;
      }
      block.push(
        `${spaces}${toProperty(property)}: ${toValue(value, transformValue)}`
      );
    }
    this.#cached = block.join(";\n");
    this.#indent = indent;
    this.#transformValue = transformValue;
    return this.#cached;
  }
}

export class StyleRule {
  styleMap;
  selectorText;
  constructor(selectorText: string, style: StylePropertyMap | Style) {
    this.selectorText = selectorText;
    this.styleMap =
      style instanceof StylePropertyMap ? style : new StylePropertyMap(style);
  }
  get cssText() {
    return this.toString();
  }
  toString({
    indent = 0,
    transformValue,
  }: { indent?: number; transformValue?: TransformValue } = {}) {
    const spaces = " ".repeat(indent);
    const content = this.styleMap.toString({
      indent: indent + 2,
      transformValue,
    });
    return `${spaces}${this.selectorText} {\n${content}\n${spaces}}`;
  }
}

export type MediaRuleOptions = {
  minWidth?: number;
  maxWidth?: number;
  mediaType?: "all" | "screen" | "print";
};

export class MediaRule {
  #name: string;
  options: MediaRuleOptions;
  rules: Map<string, StyleRule | PlaintextRule>;
  #mediaType;
  constructor(name: string, options: MediaRuleOptions = {}) {
    this.#name = name;
    this.options = options;
    this.rules = new Map();
    this.#mediaType = options.mediaType ?? "all";
  }
  insertRule(rule: StyleRule | PlaintextRule) {
    this.rules.set(
      rule instanceof StyleRule ? rule.selectorText : rule.cssText,
      rule
    );
    return rule;
  }
  get cssText() {
    return this.toString();
  }
  toString() {
    return this.generateRule({ nestingRules: [] });
  }
  generateRule({
    nestingRules,
    transformValue,
  }: {
    nestingRules: NestingRule[];
    transformValue?: TransformValue;
  }) {
    if (this.rules.size === 0 && nestingRules.length === 0) {
      return "";
    }
    const rules = [];
    for (const rule of this.rules.values()) {
      rules.push(rule.toString({ indent: 2, transformValue }));
    }
    for (const rule of nestingRules) {
      const generatedRule = rule.toString({
        breakpoint: this.#name,
        indent: 2,
        transformValue,
      });
      if (generatedRule !== "") {
        rules.push(generatedRule);
      }
    }
    // avoid rendering empty media queries
    if (rules.length === 0) {
      return "";
    }
    let conditionText = "";
    const { minWidth, maxWidth } = this.options;
    if (minWidth !== undefined) {
      conditionText = ` and (min-width: ${minWidth}px)`;
    }
    if (maxWidth !== undefined) {
      conditionText += ` and (max-width: ${maxWidth}px)`;
    }
    return `@media ${this.#mediaType}${conditionText} {\n${rules.join(
      "\n"
    )}\n}`;
  }
}

export class PlaintextRule {
  cssText;
  constructor(cssText: string) {
    this.cssText = cssText;
  }
  toString() {
    return this.cssText;
  }
}

export type FontFaceOptions = {
  fontFamily: string;
  fontStyle?: "normal" | "italic" | "oblique";
  fontWeight?: number | string;
  fontDisplay: "swap" | "auto" | "block" | "fallback" | "optional";
  src: string;
};

export class FontFaceRule {
  #cached: undefined | string;
  #options: FontFaceOptions;
  constructor(options: FontFaceOptions) {
    this.#options = options;
  }
  get cssText() {
    return this.toString();
  }
  toString() {
    if (this.#cached) {
      return this.#cached;
    }
    const decls = [];
    const { fontFamily, fontStyle, fontWeight, fontDisplay, src } =
      this.#options;
    const value = toValue(
      { type: "fontFamily", value: [fontFamily] },
      // Avoids adding a fallback automatically which needs to happen for font family in general but not for font face.
      (value) => value
    );
    decls.push(`font-family: ${value}`);
    decls.push(`font-style: ${fontStyle}`);
    decls.push(`font-weight: ${fontWeight}`);
    decls.push(`font-display: ${fontDisplay}`);
    decls.push(`src: ${src}`);
    this.#cached = `@font-face {\n  ${decls.join("; ")};\n}`;
    return this.#cached;
  }
}
